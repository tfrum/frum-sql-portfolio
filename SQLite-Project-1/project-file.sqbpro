<?xml version="1.0" encoding="UTF-8"?><sqlb_project><db path="/home/tveh/Documents/GitHub/frum-sql-portfolio/SQLite-Project-1/database.db" readonly="0" foreign_keys="1" case_sensitive_like="0" temp_store="0" wal_autocheckpoint="1000" synchronous="2"/><attached/><window><main_tabs open="structure browser pragmas query" current="3"/></window><tab_structure><column_width id="0" width="300"/><column_width id="1" width="0"/><column_width id="2" width="100"/><column_width id="3" width="4955"/><column_width id="4" width="0"/><expanded_item id="0" parent="1"/><expanded_item id="1" parent="1"/><expanded_item id="2" parent="1"/><expanded_item id="3" parent="1"/></tab_structure><tab_browse><current_table name="4,17:maincountry_iso_codes"/><default_encoding codec=""/><browse_table_settings><table schema="main" name="country_iso_codes" show_row_id="0" encoding="" plot_x_axis="" unlock_view_pk="_rowid_"><sort/><column_widths><column index="1" value="113"/></column_widths><filter_values/><conditional_formats/><row_id_formats/><display_formats/><hidden_columns/><plot_y_axes/><global_filter/></table><table schema="main" name="country_population" show_row_id="0" encoding="" plot_x_axis="" unlock_view_pk="_rowid_"><sort/><column_widths><column index="1" value="300"/><column index="2" value="113"/><column index="3" value="96"/><column index="4" value="96"/><column index="5" value="96"/><column index="6" value="96"/><column index="7" value="96"/><column index="8" value="96"/><column index="9" value="96"/><column index="10" value="96"/><column index="11" value="96"/><column index="12" value="96"/><column index="13" value="96"/><column index="14" value="96"/><column index="15" value="96"/><column index="16" value="96"/><column index="17" value="96"/><column index="18" value="96"/><column index="19" value="96"/><column index="20" value="96"/><column index="21" value="96"/><column index="22" value="96"/><column index="23" value="96"/><column index="24" value="96"/><column index="25" value="96"/><column index="26" value="96"/><column index="27" value="96"/><column index="28" value="96"/><column index="29" value="96"/><column index="30" value="96"/><column index="31" value="96"/><column index="32" value="96"/><column index="33" value="96"/><column index="34" value="96"/><column index="35" value="96"/><column index="36" value="96"/><column index="37" value="96"/><column index="38" value="96"/><column index="39" value="96"/><column index="40" value="96"/><column index="41" value="96"/><column index="42" value="96"/><column index="43" value="96"/><column index="44" value="96"/><column index="45" value="96"/><column index="46" value="96"/><column index="47" value="96"/><column index="48" value="96"/><column index="49" value="96"/><column index="50" value="96"/><column index="51" value="96"/><column index="52" value="96"/><column index="53" value="96"/><column index="54" value="96"/><column index="55" value="96"/><column index="56" value="96"/><column index="57" value="109"/><column index="58" value="96"/><column index="59" value="96"/></column_widths><filter_values/><conditional_formats/><row_id_formats/><display_formats/><hidden_columns/><plot_y_axes/><global_filter/></table></browse_table_settings></tab_browse><tab_sql><sql name="1. Data Clean and Table Creation.sql">/* In this project I'm going to process
   and reorganize three tables of demographic data
   sourced from Kaggle. The code is SQLite and the project
   is being done in DB Browser.
   
   I've included the unmodified CSV files.*/

/* We'll need to combine them all according to a common key.
   But first I need to inspect and reorganize my data.
   about what data I'll I use from this database.*/

/* If I were using sqlite3 in python I would import THEN
   .csv files to tables here using code like:
   
      sqlite&gt; .import 'raw_data/country_population.csv' country_population --csv
	  
   But for now just load raw.db if you want to get the tables.*/

SELECT *
FROM country_population, fertility_rate, life_expectancy;

/* We have a problem before we combine these tables. 
   They share a *lot* of keys since the data is organized by year.
   
   Another issue is that some of those decimal places are extremely long.
   I should truncate those, but I'll do that later.*/

/* We'll do some cleaning. We don't need these indicator columns since 
   we can know that in other ways. Unfortunately SQLite isn't concise here.*/

ALTER TABLE country_population
DROP COLUMN IndicatorName;

ALTER TABLE country_population
DROP COLUMN IndicatorCode;

ALTER TABLE fertility_rate
DROP COLUMN IndicatorName;

ALTER TABLE fertility_rate
DROP COLUMN IndicatorCode;

ALTER TABLE life_expectancy
DROP COLUMN IndicatorName;

ALTER TABLE life_expectancy
DROP COLUMN IndicatorCode;

/* At this point I would normally turn to a python script to automate this.
   Instead let's just limit the scope a bit to a couple of years. Our first and last.*/
   
ALTER TABLE country_population
RENAME COLUMN &quot;2016&quot; TO pop2016;

ALTER TABLE country_population
RENAME COLUMN &quot;1960&quot; TO pop1960;

ALTER TABLE fertility_rate
RENAME COLUMN &quot;2016&quot; TO fert2016;

ALTER TABLE fertility_rate
RENAME COLUMN &quot;1960&quot; TO fert1960;

ALTER TABLE life_expectancy
RENAME COLUMN &quot;2016&quot; TO life2016;

ALTER TABLE life_expectancy
RENAME COLUMN &quot;1960&quot; TO life1960;

-- Now let's merge these tables together.

/* If I weren't using SQLite I would do this differently. This is another opportunity to use Python
   to automate the query for a larger database. */

-- I want to make a table to merge the data into. 
CREATE TABLE merged_data (
  CountryName TEXT,
  CountryCode TEXT,
  pop1960 REAL,
  pop2016 REAL,
  fert1960 REAL,
  fert2016 REAL,
  life1960 REAL,
  life2016 REAL
);

-- Now let's fill this table with data.

INSERT INTO merged_data
SELECT  c.CountryName, c.CountryCode,
        p.pop1960, p.pop2016,
        f.fert1960, f.fert2016,
        l.life1960, l.life2016
FROM country_population p
INNER JOIN fertility_rate f ON p.CountryCode = f.CountryCode AND p.CountryName = f.CountryName
INNER JOIN life_expectancy l ON p.CountryCode = l.CountryCode AND p.CountryName = l.CountryName
INNER JOIN (
  SELECT DISTINCT CountryCode, CountryName
  FROM country_population
) c ON p.CountryCode = c.CountryCode AND p.CountryName = c.CountryName;

-- So did that work?


-- It did! But now I want to do something about these decimal points.

/* I could manually do this, or generate a large query, or use python.
   However I want to move a little out of my comfort zone here. */
   
SELECT group_concat('UPDATE merged_data SET &quot;' || name || '&quot; = ROUND(&quot;' || name || '&quot;, 3); ', '') 
FROM pragma_table_info('merged_data');

/* This is another place where SQLite has some limitations. AFAIK you can't assign the statement that 
   was just generated to a variable to execute automatically here. */
   
/* The resulting code from that statement:   
   UPDATE merged_data SET &quot;CountryName&quot; = ROUND(&quot;CountryName&quot;, 3);
   UPDATE merged_data SET &quot;CountryCode&quot; = ROUND(&quot;CountryCode&quot;, 3);
   UPDATE merged_data SET &quot;pop1960&quot; = ROUND(&quot;pop1960&quot;, 3);
   UPDATE merged_data SET &quot;pop2016&quot; = ROUND(&quot;pop2016&quot;, 3);
   UPDATE merged_data SET &quot;fert1960&quot; = ROUND(&quot;fert1960&quot;, 3);
   UPDATE merged_data SET &quot;fert2016&quot; = ROUND(&quot;fert2016&quot;, 3);
   UPDATE merged_data SET &quot;life1960&quot; = ROUND(&quot;life1960&quot;, 3);
   UPDATE merged_data SET &quot;life2016&quot; = ROUND(&quot;life2016&quot;, 3); 
   
   So why did I comment that? Well, it'll ruin our table, that's why! I can't round a string!
   This is another limitation of SQLite.*/

SELECT group_concat('UPDATE merged_data SET &quot;' || name || '&quot; = ROUND(&quot;' || name || '&quot;, 3); ', '') 
FROM pragma_table_info('merged_data')
WHERE type &lt;&gt; 'TEXT';

-- That's better. We get this as our concatenated statement:
UPDATE merged_data SET &quot;pop1960&quot; = ROUND(&quot;pop1960&quot;, 3); 
UPDATE merged_data SET &quot;pop2016&quot; = ROUND(&quot;pop2016&quot;, 3); 
UPDATE merged_data SET &quot;fert1960&quot; = ROUND(&quot;fert1960&quot;, 3); 
UPDATE merged_data SET &quot;fert2016&quot; = ROUND(&quot;fert2016&quot;, 3); 
UPDATE merged_data SET &quot;life1960&quot; = ROUND(&quot;life1960&quot;, 3); 
UPDATE merged_data SET &quot;life2016&quot; = ROUND(&quot;life2016&quot;, 3); 
   
SELECT *
FROM merged_data;

-- That worked perfectly!


</sql><sql name="2. Exploring Data.sql">/* While our new table, merged_data, isn't large that doesn't mean
   it can't be used to do interesting things. Let's ask some questions.*/
   
-- How much has the United States changed in 56 years?

EXPLAIN QUERY PLAN SELECT pop1960, pop2016
FROM merged_data
WHERE CountryCode = &quot;USA&quot;;

-- Sadly our index didn't save us any time.

-- How many people have we added as a species?

SELECT SUM(pop1960)
FROM merged_data;

-- That's hard to read.

SELECT printf('%,d', SUM(pop1960))
as total_sum
FROM merged_data;

-- 30 Billion People in 1960 doesn't sound right. Let's look closer.

SELECT CountryCode, CountryName, pop1960
FROM merged_data
WHERE pop1960 &gt; 1.0E9;

/* And so we've discovered that our dataset has some issues. Despite it being labeled as countries it
   it also includes non-country categories. We have two ways of handling this.
   First, I can fetch the ISO 3166-1 alpha-3 list of country codes and then just compare those.*/
   
DELETE FROM merged_data
WHERE CountryCode NOT IN (
	SELECT CountryCode FROM country_iso_codes
);

-- Now let's see what we've got.

SELECT printf('%,d', SUM(pop1960))
as total_sum
FROM merged_data;
</sql><current_tab id="1"/></tab_sql></sqlb_project>
